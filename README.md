# MATLAB_GNUOctave
## TASK1

### Description:

The implemented program aims to find the best path for the robot to escape from a labyrinth. To find the optimal solution, I created a simple algorithm that takes into consideration the probability of reaching a winning zone by randomly choosing available directions for movement. The robot can move up, down, left, or right, but not diagonally. The labyrinth may contain walls that prevent the robot from moving between adjacent cells spatially. To identify the best possibilities, the program uses a method to determine the probability of reaching a winning exit in the labyrinth. The winning exits are located at the top or bottom and overlap with the upper and lower boundaries of the labyrinth. If the robot chooses such an exit, it is considered a win. The losing exits are located on the left or right and overlap with the side boundaries of the labyrinth. If the robot chooses such an exit, it is considered a loss. In the end, the program proposes an efficient solution to determine a path for the robot through the labyrinth using the probability data obtained in a more intelligent way than exhaustive search.

For this project, several functions were implemented:

- `parse_labyrinth`: Parses the text file containing the encoded representation of a labyrinth and transforms it into a matrix. The purpose of this function is to read the file and construct the corresponding labyrinth matrix.

- `get_adjacency_matrix`: Transforms the matrix obtained from parsing the labyrinth into an adjacency matrix of the corresponding graph/Markov chain. The purpose of this function is to calculate the adjacency matrix of the labyrinth's associated graph. For this function, some improvements were made that were not required in the task. The adjacency matrix construction function analyzes the encoding and creates a wall between two cells even if the encoding of the adjacent cell does not correspond to a wall. This approach helps avoid potential errors in case an invalid encoding is given, and the program can continue by considering the wall on both sides. Specific information about the labyrinth's encoding: The labyrinth is stored as a matrix with m x n elements, where each integer represents 4 bits, and each bit set to 1 represents a possible wall that blocks movement in the respective direction. In the used encoding, the set b3 bit indicates the presence of a wall to the north of the cell, the set b2 bit indicates the presence of a wall to the south, the set b1 bit indicates the presence of a wall to the east, and the set b0 bit indicates the presence of a wall to the west.

- `get_link_matrix`: Transforms the matrix of encodings of a valid labyrinth into a corresponding link matrix. The purpose of this function is to construct the link matrix associated with the given labyrinth. For implementation, we start with the adjacency matrix and observe that instead of 1, we need to use 1 divided by the sum of elements in each row. We iterate through the adjacency matrix and create the link matrix using the discovered rule.

- `get_Jacobi_parameters`: Calculates the matrix and iteration vector for the Jacobi method using the previously obtained link matrix. The purpose of this function is to calculate the parameters required for applying the Jacobi method to find the solution of the system. We utilize the theory from the course. We know that A = N - P and A = D + L + U, where D is the diagonal matrix, L is the lower triangular matrix, and U is the upper triangular matrix. We specialize for the Jacobi case where N = D. Matrix G is the inverse of N * P, and c is the inverse of N * the vector b (the solutions).

- `perform_iterative`: Applies the iterative method to find the solution of the system. The purpose of this function is to apply the Jacobi iterative method to find the solution of the system of equations. We utilize the previously calculated matrix and vector, as well as the initial guess x_0. We perform iterations using the formula x_i = G * x_{i-1} + c until convergence.

- `find_winning_probability`: Calculates the probability of reaching a winning zone for each cell in the labyrinth. The purpose of this function is to determine the probability of reaching a winning zone for each cell in the labyrinth using the iterative method. We initialize a probability vector and use the Jacobi method to update the probabilities until convergence. We continue iterating until the probabilities for all cells stabilize.

- `find_best_path`: Finds the best path for the robot to escape from the labyrinth. The purpose of this function is to determine the best path for the robot to escape from the labyrinth based on the probabilities calculated in the previous step. We start from the cell with the highest probability of reaching a winning zone and move towards the winning exit. We continue moving to adjacent cells with higher probabilities until we reach the winning exit. The resulting path is the best path for the robot to escape.

Note: The above functions represent the core logic and steps involved in finding the best path for the robot to escape from the labyrinth.
